### REST (CRUD OPERATION) USING SPING-BOOT

In this one we are going to create a simple REST API to perform ``CRUD``
operations using [Spring boot](https://spring.io/projects/spring-boot).

### Getting started
We are going to make use of the [Spring initializr](https://start.spring.io/) to initialize our
spring-boot project. **How?**

1. Go to [Spring initializr](https://start.spring.io/)
2. Under project metadata rename your project
3. Click add dependencies
    * In this simple rest app we are going to use
        * Spring Web - to create REST
        * Spring Data JPA - to connect to our database
        * PostgreSQL Driver - we are going to use PostgreSQL as our database.
4. [Click here to download the boiler plate](https://start.spring.io/#!type=maven-project&language=java&platformVersion=2.5.4&packaging=jar&jvmVersion=16&groupId=com.rest&artifactId=rest&name=rest&description=Demo%20project%20for%20Spring%20Boot&packageName=com.rest.rest&dependencies=web,data-jpa,postgresql)
5. Unzip the zipped version of the project startup
6. Then we will open it in our ide. 

### Tools
* For the IDE I'm using InteliJ
* I'm using Postman and Hoppscotch to make API requests to our server.


### Errors

If you open ``java/com.rest.rest`` and get the following error:
````
Cannot resolve method 'run(java.lang.Class, String[])'
````
Then **make sure that `JDK` (SDK) is configured in your project**.


### Hello world
If we try to run the application right now we are going to get an error. This error is caused by `jpa`. Inorder to start our application without any problem
and write our hello world API we need to navigate to the root folder and locate our
``pom.xml`` file. We need to comment out the following dependency that is preventing our
application from running.

```xml
<!--		<dependency>-->
<!--			<groupId>org.springframework.boot</groupId>-->
<!--			<artifactId>spring-boot-starter-data-jpa</artifactId>-->
<!--		</dependency>-->
```

After that we can run our application and it will be listening on port: ``8080``
so if we visit http://localhost:8080 we will get a default page which looks as follows.

````
Whitelabel Error Page
This application has no explicit mapping for /error, so you are seeing this as a fallback.

Tue Sep 21 19:18:56 SAST 2021
There was an unexpected error (type=Not Found, status=404).
````
This is because the code in our ``RestApplication.java`` looks as follows:

```java
package com.rest.rest;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
@SpringBootApplication
public class RestApplication {
	public static void main(String[] args) {
		SpringApplication.run(RestApplication.class, args);
	}
}
```

There's no more logic in this file. Next we are going to create our ``helloWord``
route and see what we will get. 

```java
package com.rest.rest;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.*;
@SpringBootApplication
@RestController
public class RestApplication {
	public static void main(String[] args) {
		SpringApplication.run(RestApplication.class, args);
	}
	@GetMapping
	public String helloWord(){
		return "Hello, World.";
	}
}
```

### What are we going to create?
We are going to create a simple REST application that will ADD, REMOVE, UPDATE and GET
users from our database. The first thing that we are going to do is to create a
package called `user`. In this package we are going to have all the logic in this package `folder`.

Let's create a ``User`` class in this package and define properties, Constructors Getters and Setters.

```java
package com.rest.rest.user;

import java.time.LocalDate;
import java.util.Date;

public class User {
    private String name;
    private Long id;
    private String email;
    private LocalDate dob;
    private int age;

    // the reason i did not include the ID in here is because it will be generated by the database
    public User(String name, String email, LocalDate dob, int age){
        this.name = name;
        this.email = email;
        this.dob = dob;
        this.age = age;
    }
    public User(Long id, String name, String email, LocalDate dob, int age){
        this.name = name;
        this.id = id;
        this.email = email;
        this.dob = dob;
        this.age = age;
    }
    // Setters
    public void setEmail(String email) {
        this.email = email;
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public void setDob(LocalDate dob) {
        this.dob = dob;
    }
    public void setAge(int age) {
        this.age = age;
    }

    // Getters
    public LocalDate getDob() {
        return dob;
    }
    public Long getId() {
        return id;
    }
    public String getEmail() {
        return email;
    }
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", id=" + id +
                ", email='" + email + '\'' +
                ", dob=" + dob +
                ", age=" + age +
                '}';
    }
}
```

Then we will go to our `helloWorld` method inside the `RestApplication.java` file and add the following code:

```java
@SpringBootApplication
@RestController
public class RestApplication {
	public static void main(String[] args) {
		SpringApplication.run(RestApplication.class, args);
	}
	@GetMapping
	public ArrayList<User> helloWord(){
		String names [] = {"name1", "name2", "name3"};
		String emails [] = {"name1@gmail.com", "name2@gmail.com", "name3@gmail.com"};
		int ages[] = {12, 23, 78};
		Long ids[] = {1L, 2L, 3L};
		LocalDate dobs[] = {
				LocalDate.of(1999, 5, 7),
				LocalDate.of(1999, 5, 7),
				LocalDate.of(1999, 5, 7),
		};

		ArrayList<User> myUsers = new ArrayList<>();
		for (int i=0; i<names.length; i++){
			myUsers.add(new User(ids[i],names[i], emails[i], dobs[i], ages[i]));
		}
		return myUsers;
	}
}
```

Then now if we visit http://localhost:8080/ we will get the following ``json`` response:

```json
[
   {
      "name": "name1",
      "id": 1,
      "email": "name1@gmail.com",
      "dob": "1999-05-07",
      "age": 12
   },
   {
      "name": "name2",
      "id": 2,
      "email": "name2@gmail.com",
      "dob": "1999-05-07",
      "age": 23
   },
   {
      "name": "name3",
      "id": 3,
      "email": "name3@gmail.com",
      "dob": "1999-05-07",
      "age": 78
   }
]
```
### Controllers and database linkup

We have implemented our first rest API with some dummy data. Next we are going to pull up the 
database. First of all let's make our code cleaner by creating a ``UserController`` class in the user package. This is where 
our get, post, put and delete mapping wil be handled. Now in our ``user/UserController.java`` we will have the following code in it:

```java
package com.rest.rest.user;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.time.LocalDate;
import java.util.ArrayList;

@RestController
@RequestMapping(path = "/api/v1/user")
public class UserController {
    @GetMapping
    public ArrayList<User> getUsers(){
        String names [] = {"name1", "name2", "name3"};
        String emails [] = {"name1@gmail.com", "name2@gmail.com", "name3@gmail.com"};
        int ages[] = {12, 23, 78};
        Long ids[] = {1L, 2L, 3L};
        LocalDate dobs[] = {
                LocalDate.of(1999, 5, 7),
                LocalDate.of(1999, 5, 7),
                LocalDate.of(1999, 5, 7),
        };

        ArrayList<User> myUsers = new ArrayList<>();
        for (int i=0; i<names.length; i++){
            myUsers.add(new User(ids[i],names[i], emails[i], dobs[i], ages[i]));
        }
        return myUsers;
    }
}
```
We just decorated our class with ``@RequestMapping(path = "/api/v1/user")`` where the path specified is very important when now querying the api. Instead of going to the
http://localhost:8080/ we are now going to http://localhost/api/v1/user

Going back to the `RestApplication.java` we will have the following code in it:
```java
package com.rest.rest;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
@SpringBootApplication
public class RestApplication {
	public static void main(String[] args) {
		SpringApplication.run(RestApplication.class, args);
	}
}
```

From now on all the logic related to users and the database will be happening in the ``UserController``.


### Creating a Service
We can go ahead and create a UserService and move all of our methods from the ``UserController`` to the `UserService`. Let's go ahead and create a class inside the student package called `UserService` and we will add the following code into it:

```java
@Service
public class UserService {
    public ArrayList<User> getUsers(){
        String names [] = {"name1", "name2", "name3"};
        String emails [] = {"name1@gmail.com", "name2@gmail.com", "name3@gmail.com"};
        int ages[] = {12, 23, 78};
        Long ids[] = {1L, 2L, 3L};
        LocalDate dobs[] = {
                LocalDate.of(1999, 5, 7),
                LocalDate.of(1999, 5, 7),
                LocalDate.of(1999, 5, 7),
        };

        ArrayList<User> myUsers = new ArrayList<>();
        for (int i=0; i<names.length; i++){
            myUsers.add(new User(ids[i],names[i], emails[i], dobs[i], ages[i]));
        }
        return myUsers;
    }
}
```
We have copied the ``getUsers`` method from the `UserController` and pasted it in the `UserService` class. But we also decorated 
or annotated the ``UserService`` with the `@Service` this is telling spring boot that this class is a spring boot `Bin`.

> Note we can also use `@Component` instead of `@Service` they are almost the same, but to be more specific we used the 
> `@Service` since it is a service.


Inside the `UserController` we will then initialize an instance of ``UserService`` and created a constructor method that will
automatically initiate the ``UserService`` class and give us back a ``UserService`` object. But for this to work we have to go
ahead and decorate our constructor with ``@Autowired`` we are telling spring boot that the ``UserService`` should be automatically
initiated in the constructor. Therefore our ``UserController.java`` will be looking as follows:

```java
@RestController
@RequestMapping(path = "/api/v1/user")
public class UserController {
    private final UserService userService;

    /*
     @Autowired  - we are telling spring book to automatically initiate the UserService for us
                 - aka dependence injection
     */
    @Autowired
    public UserController(UserService userService){
        this.userService = userService;
    }
    @GetMapping
    public ArrayList<User> getUsers(){
        return  this.userService.getUsers();
    }
}
```

### Connecting to the database.
For the database we are going to use the POSTGRESQL database. We are going to navigate to the `resources/application.properties` file and add the following properties in that file

````
spring.datasource.url=jdbc:postgresql://localhost:5432/user_database
spring.datasource.username=postgres
spring.datasource.password=root
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true
server.errors.include-message=always # include error messages that are thrown by the server in the response object
````

Then create a database named ``user_database`` using `psql` command.

```roomsql
CREATE DATABASE user_database;
```

### Connecting to the database

Let's go back to our `pom.xml` and uncomment the dependence that we have commented earlier:

```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```
After running the server we will be connected to our database.

### Creating Entities aka Tables
Now that we have connected to our database, we can now move on and create our table that will store users. We are going to our
`Users` class and add the following code to it.

> **Note** I've renamed the class to `Users` because ``User`` is clashing in the postgres database.

```java
@Entity
@Table
public class Users {
   @Id
   @SequenceGenerator(
           name="user_sequence",
           sequenceName = "user_sequence",
           allocationSize = 1
   )
   @GeneratedValue(
           strategy = GenerationType.SEQUENCE,
           generator = "user_sequence"
   )
   private String name;
   private Long id;
   private String email;
   private LocalDate dob;
   private int age;
   ...
}
```
When we add the following code and restart the server a new table will be created in our database with the property 
that the user has.

### Creating a Repository 

Next we are going to create an interface called ``UserRepository`` inside our user package. This interface will extents from `JpaRepository<T, I>`
with two generics `T` and `I` where T is the UserType which is basically the Users class and I is the type of the ID of this UserType.


```java
package com.rest.rest.user;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<Users, Long> {
}
```

Now inside the user controller we are going to create an instance of a `UserRepository` which we will use it's method to
pesist data and query from the database. We will remove our hard coded user and the `UserService` will be looking as follows:

```java
@Service
public class UserService {
    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository){
        this.userRepository = userRepository;
    }

    public List<Users> getUsers(){
        return userRepository.findAll();
    }
}
```

On our example we want to make sure that we are not going to store the age in the database since it can be calculated from 
the date of birth. We are going to make use of the ``@Transient`` annotation tell jpa that we want to skip the column age 
when creating a table. Now the ``Users`` class will be looking as follows:

```java
package com.rest.rest.user;

import javax.persistence.*;
import java.time.LocalDate;
import java.time.Period;

@Entity
@Table
public class Users {
   @Id
   @SequenceGenerator(
           name="user_sequence",
           sequenceName = "user_sequence",
           allocationSize = 1
   )
   @GeneratedValue(
           strategy = GenerationType.SEQUENCE,
           generator = "user_sequence"
   )
   private Long id;
   private String name;
   private String email;
   private LocalDate dob;
   @Transient
   private Integer age;

   public  Users(){} // Default constructor required
   // the reason i did not include the ID in here is because it will be generated by the database

   public Users(Long id, String name, String email, LocalDate dob){
      this.name = name;
      this.id = id;
      this.email = email;
      this.dob = dob;
   }
   public Users(String name, String email, LocalDate dob){
      this.name = name;
      this.email = email;
      this.dob = dob;
   }
   // Setters
   public void setEmail(String email) {
      this.email = email;
   }
   public void setName(String name) {
      this.name = name;
   }
   public void setId(Long id) {
      this.id = id;
   }
   public void setDob(LocalDate dob) {
      this.dob = dob;
   }
   public void setAge(Integer age) {
      this.age = age;
   }

   // Getters
   public LocalDate getDob() {
      return dob;
   }
   public Long getId() {
      return id;
   }
   public String getEmail() {
      return email;
   }
   public String getName() {
      return name;
   }
   public Integer getAge() {
      return Period.between(this.dob, LocalDate.now()).getYears();
   }

   @Override
   public String toString() {
      return "User{" +
              "name='" + name + '\'' +
              ", id=" + id +
              ", email='" + email + '\'' +
              ", dob=" + dob +
              ", age=" + age +
              '}';
   }
}

```
Now if we run the program and look at sql logs we wil notice that the student age column will not be created in our
database. That's what we want the magic of the ``@Transient`` annotation. The sql logs will look as follows:

```roomsql
 create table users (
       name varchar(255) not null,
        dob date,
        email varchar(255),
        id int8,
        primary key (name)
)
```

### Posting the data to the database.

We always want clean code. For simple validation we are going to check if the email is taken or not. So we want to create
an `Optional` method in our `UserRepository` as follows:

```java
// UserRepository.java

@Repository
public interface UserRepository extends JpaRepository<Users, Long> {
   Optional<Users> findByEmail(String email);
}
```
Now we will go to the `UserService` class and implement the creation of the user as follows.
```java
// UserService.java

@Service
public class UserService {
   private final UserRepository userRepository;

   @Autowired
   public UserService(UserRepository userRepository){
      this.userRepository = userRepository;
   }
   public List<Users> getUsers() {
      return userRepository.findAll();
   }
   public Users createUser(Users user){
      Optional<Users> userFound = this.userRepository.findByEmail(user.getEmail());
      if(userFound.isPresent()) {
         throw new IllegalStateException("the email is already taken.");
      }
      return this.userRepository.save(user);
   }
}
```
If there's no user we are going to throw a simple exception otherwise we save the user to the database using the ``userRepository.save()`` methid.


In our user controller we are going to add the `PostMapping` annotation to the `createUser` method implementation
and we will tell JPA that we want to accept the ``request.body`` from the client of type user using the `@RequestBody`
annotation

```java
@RestController
@RequestMapping(path = "/api/v1/user")
public class UserController {
    private final UserService userService;
    @Autowired
    public UserController(UserService userService){
        this.userService = userService;
    }

    @GetMapping(path = "/all-users")
    public List<Users> getUsers(){
        return  this.userService.getUsers();
    }

   @PostMapping(path = "/create-user")
   public Users createUser (@RequestBody Users userEntity){
      return this.userService.createUser(userEntity);
   }
}
```

Now everything is working fine if we go to the http://localhost:8080/api/v1/user/all-users route we will get no users array
let's try to create a single user using the post method.


Now if we go to postman and [POST] at http://localhost:8080/api/v1/user/create-user with the following request body.

```json
{
    "email": "user1@gmail.com",
    "dob": "1999-05-05",
    "name": "user1"
}
```
We will get the following response
```json
{
    "id": 1,
    "name": "user1",
    "email": "user1@gmail.com",
    "dob": "1999-05-05",
    "age": 22
}
```
Now if we go to the http://localhost:8080/api/v1/user/all-users with the [GET] method in POSTMAN we will get the 
following response.

```json
[
    {
        "id": 1,
        "name": "user1",
        "email": "user1@gmail.com",
        "dob": "1999-05-05",
        "age": 22
    }
]
```

### Deleting the user.

Now we want to handle the logic of deleting the user from our database. In the UserController we are going to add
 the following mapping.

```java
//UserController.java

@DeleteMapping(path = "/delete-user/{userId}")
    public Boolean deleteUser(@PathVariable("userId") Long id){
        return this.userService.deleteUser(id);
}
```
In the UserService we are going to add the following service in it
````java
//UserService.java
 public Boolean deleteUser(Long id){
        Optional<Users> usersOptional = this.userRepository.findUserById(id);
        if(!usersOptional.isPresent()){
           throw new IllegalStateException("the user with that id does not exists");
        }
        this.userRepository.deleteById(id);
        return true;
    }
````

### Updating the user
During updating of the user we are going to make use of setters. The User Controller will be looking as follows

```java
package com.rest.rest.user;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(path = "/api/v1/user")
public class UserController {
    private final UserService userService;
    @Autowired
    public UserController(UserService userService){
        this.userService = userService;
    }

    @GetMapping(path = "/all-users")
    public List<Users> getUsers(){
        return  this.userService.getUsers();
    }

    @PostMapping(path = "/create-user")
    public Users createUser (@RequestBody Users userEntity){
        return this.userService.createUser(userEntity);
    }

    @DeleteMapping(path = "/delete-user/{userId}")
    public Boolean deleteUser(@PathVariable("userId") Long id){
        return this.userService.deleteUser(id);
    }

    @PutMapping(path = "/update-user/{userId}")
    public Users updateUser(
            @PathVariable("userId") Long id,
            @RequestParam(required = false) String name,
            @RequestParam(required = false) String email
    ){
        return this.userService.updateUser(id, email, name);
    }

}
```

In our User service we will have the following code it it:

```java

package com.rest.rest.user;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.transaction.Transactional;
import java.util.List;
import java.util.Optional;


@Service
public class UserService {
    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository){
        this.userRepository = userRepository;
    }
    public List<Users> getUsers() {
        return userRepository.findAll();
    }
    public Users createUser(Users user){
        Optional<Users> userFound = this.userRepository.findByEmail(user.getEmail());
        if(userFound.isPresent()) {
            throw new IllegalStateException("the email is already taken.");
        }
        return this.userRepository.save(user);
    }
    public Boolean deleteUser(Long id){
        Optional<Users> usersOptional = this.userRepository.findUserById(id);
        if(!usersOptional.isPresent()){
           throw new IllegalStateException("the user with that id does not exists");
        }
        this.userRepository.deleteById(id);
        return true;
    }

    @Transactional
    public Users updateUser(Long id, String email, String name){
        Users user = this.userRepository.findUserById(id).orElseThrow(()-> new IllegalStateException(
                "the user with that id does not exist"));
        if(!user.getName().equals(name) && name != null){
            user.setName(name);
        }
        if(!user.getName().equals(email) && email != null){
            Optional<Users> emailFound = this.userRepository.findByEmail(email);
            if(emailFound.isPresent()){
                throw new IllegalStateException("the email is already taken");
            }else {
                user.setEmail(email);
            }
        }
        return user;
    }
}
```
So now if we go to http://localhost:8080/api/v1/user/update-user/1?name=hello2&email=hello2@gmail.com and send a [PUT]
request we are going to get the following response back:

```json
{
    "id": 1,
    "name": "hello2",
    "email": "hello2@gmail.com",
    "dob": "1999-05-05",
    "age": 22
}
```

Now we are done building our application, let's move on and package our application.

### Packaging our application.

1. If you are using IntelliJ on the Top Right conner click on the <button>Maven</button> tab
2. Click ``clean`` under Lifecycle
    * this will delete the `target` folder for us
3. Click the ``install``
4. After the installation is complete then we can open the ``cmd`` and navigate to the `target` folder 

```shell
cd target
```
5. Then we will run the following command

````shell
java -jar <name of the jar>
````

In our case :

````shell
java -jar rest-0.0.1-SNAPSHOT.jar
````

Once you run that command then the server will spin up and we will be ready to make 
our request to the server.


### Refs
* [Spring initializr](https://start.spring.io/)
* [Spring Boot](https://spring.io/projects/spring-boot)